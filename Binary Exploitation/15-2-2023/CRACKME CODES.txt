CRACKME 0a
g00dj0b!

CRACKME 0b
w0wgreat
Note:
The architecture you are you arw working on matters as sometimes the
size of the requested memmory location is small and it defaults to the
normal standard which might just be a double showing a single letter
thing i did wrong : x/gs "location"
this just defaulted to double hence i coudnt see the whole word
but hence using this helps : x/ws "location"

CRACKME 1
5274
In this the cmp instruction compares the two values one which was provided and
one we have entered. and converting the hex by using p/d "hex"
we get the decimal which we would want to enter. Also extra note
when we check the input before the program is run the value that is added into the stack is shown
to be %d which is the identifier for numbers within c. Hence we get to know that the input we enter
will be taken in as a number.

CRACKME 2
338724
In this crackme the cmp instruction would compare the entered input with something
that something can be found by us as it is basically calculations with a bit of pointers
firstly we have two numbers put into the stack which are 90  and 498 when we see what is 
being done we can understand that firstly 90 is being added to 498 through eax
then the new value is squared to get the number which is being compared with. Hence we get
the number. The concept of using pointers to access the stack was a pretty obvious way
to do operations but it didnt occur to me at first. Now after the challenge the access of 
memmory locations using pointers make a lot of sense along with the major reason behind 
the existence of pointers.

CRACKME 3
338724

CRACKME 4
555
(sum of induvidual numbers == 15, another example is 12345)
Crackme 4 has a function similar to the check function which was present in crackme 3 to check
the validity of our password. Now here the difference is that unlike a caesar cipher present in
the last challenge here, we have a new function called sscanf which is a function that is used to
read numbers from within the string we choose to input hence the numbers which we enter is read as
digits and added to one another. If the string ends and the number doesnt sum up to anything which it
is compared with then we would have gotten the password incorrect option. But here we know what it is
being compared with... which is the 0xf hex which stands for 15. Which means that we must have a number
whose induvidual digits add up to 15.

CRACKME 5
8080
The crackme is similar to the previous one in that you need to have the induvidual digits add up
to a specific number which is 16 in this case. But the similarity ends here, now a new function parell
is present within check that function is able to check if the number entered is odd or even and hence
we must enter an even number for our digits to be analysed. The entering of even number is checked through
the test instruction which ands between the registers or values and the 'and' operation done with 0x1
which basically gives us an idea of the last digit on if it is even or not if it is even eax would be 0
else it turns one. Hence entering a number summing up to 16 and it being an even is the password for this
level. This level had me a bit confused about if what was being added to the stack was a value or an address
but i now understand it. 
doubt : why is sscanf's output redirected to a pointer within the stack and why is it not readable.

CRACKME 6
set env LOL="lol"	
The main function does the job of taking in the input and making it accessible from within the stack.

The check function is where the first fail condition occurs where if the sum of the digits add up to 16 then
we get through to the next function which is our parell function which is a function that checks 

The parell function has the same input as the check function. again the input leads to the dummy function
which does something on the input data and then parell checks the same conditions as before in that it is
an even number which is entered.
Now finally the dummy function we can see is accessing very high memory locations these locations are where the
environment variable is stored now when we see, it is being looped to access all environment variables and would
give us the output of 1 if the environment variable is set which has the name LOLO or LOL"somethingelse".
The way you can identify that it is accessing the environment variables is through dynamic analysis of the binary.

CRACKME 7
set env LOL="lol"
password : 8080
Now this crackme was same as the other crackme but the binary is stripped hence the function names and things are not
present.